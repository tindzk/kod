# Empty list.
[]

# List with one element.
[1]

# List with three elements.
[1, 2, 3]

# Declare variable with a list.
[Int] list = [1, 2, 3, 4, 5]

# Shortcut for:
List<Int> list = [1, 2, 3, 4, 5]

list.first() == 1
list.last() == 5
list.at(2) == 3

[Str] list2 = ["Hello", "World"]
[Char] list3 = ['a', 'b', 'c']

# Construct lists of floats.
let fl = [1, 2, 3, 4, 5] as [Float]
[Float] fl2 = [1, 2, 3, 4, 5]
[Float] fl2 = [1.0, 2.0, 3.0, 4.0, 5.0]

# Construct list from range.
[18..28]

# Shorter form:
18..28

# Brackets for ranges are only necessary when it would be ambiguous otherwise.
# Also list constructors can be used to construct lists with multiple ranges
# that are all flattened (inlined).
[0, 1..5, 10, 15..17]

# Infinite list. Evaluating it will never terminate.
18..Infinity
18..
[18..]

# Operating on subsets, however, does terminate.
[1..].take(10)

# `..' is an operator defined on an Int. Therefore the above is equivalent to:
Int a = 18
Int b = 28
[Int] res = a .. b

# The resulting list is internally optimised to evaluate upon access, allowing
# the creation of infinite lists.
[Int] res = 18 .. Integer.Infinity
# Shorter:
[Int] res = 18 ..

# `..' is also defined on enumerations (see enums.kod).
EnumType.FirstElement .. EnumType.LastElement

# `in' is a right-evaluated operator. It checks whether the value on the
# LHS is existent in the list of the RHS. Currently, `in' is the only
# right-evaluated operator.
let i = 3
assert i in [2..10]

# No new operators can be defined, only those defined in the grammar are
# allowed to be overridden. This allows to define a fixed precedence level on
# the grammar level for each operator and to thus remove possible complexion
# when allowing the user to define its own operators.
assert i in 2..10

# List comprehensions are supported:
[x * 2 for x in 1..10 if x mod 2 == 0] = [4, 8, 12, 16, 20]

# With the subset operator, parts of a list can be retrieved.
let str = "hello world"
let sub = str[1:3]

# Other methods that are defined on a list:
[1, 2, 3].sum()
[1, 2, 3].product()
[[1, 2, 3], [4, 5, 6], [7, 8, 9]].flatten() == [1, 2, 3, 4, 5, 6, 7, 8, 9]
[2..10].contains(i)
[1, 2, 3].reverse()
"abc".reverse()